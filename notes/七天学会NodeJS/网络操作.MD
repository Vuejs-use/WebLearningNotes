使用 ```NodeJS``` 内置的 ```http``` 模块可以很方便的实现一个 ```HTTP``` 服务器:

```js
var http = require("http");

http.createServer(function (req, res) {
    res.writeHead(200, {"Content-Type": "text-plain"})
    res.end("<h1>hello world</h1>")
}).listen(8000)
```

需要注意一点

* 在 ```Linux``` 系统下，监听 ```1024``` 以下端口需要 ```root``` 权限，因此，如果需要监听 ```80``` 或 ```433``` 端口的化，需要使用 ```sudo``` 命令启动程序


## 网络操作相关 API

```http``` 模块提供两种使用方式：

* 作为服务端使用，创建一个 ```HTTP``` 服务器，监听 ```HTTP``` 客户端请求并返回响应

* 作为客户端使用，发起一个 ```HTTP``` 客户端请求，获取服务端响应

```HTTP``` 请求（响应也是类似的）本质上是一个数据流，由请求头（```headers```）和请求体（```body```）组成，空行之上是请求头，之下是请求体：

```js
POST / HTTP/1.1
User-Agent: curl/7.26.0
Host: localhost
Accept: */*
Content-Length: 11
Content-Type: application/x-www-form-urlencoded

Hello World
```

#### 服务端模式

```HTTP``` 请求在发送给服务器的时候，可以认为是按照从头到尾的顺序一个字节一个字节的以数据流方式发送的

而 ```HTTP``` 模块创建的 ```HTTP``` 服务器在接收到完整的请求头后，就会调用回调函数

在回调函数中，除了可以使用 ```request``` 对象访问请求头数据外，还能把 ```request``` 对象当作一个只读数据流来访问请求体数据

```js
var http = require("http");

http.createServer(function (request, response) {
    var body = [];

    console.log(request.method);
    console.log(request.headers);

    request.on("data", function (chunk) {
        body.push(chunk);
    })

    request.on("end", function () {
        body = Buffer.concat(body);
        console.log(bodt.toString());
    })
}).listen(8000)
```

在回调函数中，除了可以使用 ```response``` 对象来写入 响应头 数据外，还能把 ```response``` 对象当作一个 只写数据流 来写入 响应体 数据

```js
// 服务端原样将客户端请求的请求体数据返回给客户端
var http = require("http");

http.createServer(function (request, response) {
    response.writeHead(200, {"Contetn-Type": "text-plain"})

    request.on("data", function (chunk) {
        response.write(chunk)
    })

    request.on("end", function () {
        response.end()
    })
}).listen(8000)
```

#### 客户端模式

为了发起一个 客户端 ```HTTP``` 请求，我们需要指定目标服务器的位置并发送请求头和请求体

```js
var options = {
    hostname: "www.example.com",
    port: 8000,
    path: "/upload",
    method: "POST",
    headers: {
        "Content-Type": "application/x-www-form-urlencoded"
    }
};

var request = http.request(options, function (response) {})

request.write("hello wolrd")
request.end();
```

```.request``` 方法创建了一个客户端，并指定请求目标和请求头数据。之后就可以把 ```request``` 对象当作一个 只写数据流 来写入请求体数据和结束请求

由于 ```GET``` 请求是最常见的一种，并且不需要请求体，故可以简写为：

```js
http.get("http://www.example.com/", function (response) {});
```

当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数

在回调函数中，除了可以使用 ```response``` 对象访问响应头数据外，还能把 ```response``` 对象当作一个只读数据流来访问响应体数据


```js
http.get("http://www.example.com/", function (response) {
    var body = [];

    console.log(response.statusCode);
    console.log(response.headers);

    response.on("data", function (chunk) {
        body.push(chunk);
    });

    response.on("end", function () {
        body = Buffer.concat(body);
        console.log(body.toString());
    });
});
```


## HTTPS

```https``` 模块与 ```http``` 模块类似，区别在于 ```https``` 模块需要额外处理 ```SSL``` 证书

#### 服务端模式

```js
var options = {
    key: fs.readFileSync("./ssl/default.key"),
    cert: fs.readFileSync("./ssl/default.cer")
}

var server = https.createServer(options, function (request, response) {
    // ...
})
```

与创建 ```HTTP``` 服务器相比，多了一个 ```options``` 对象，通过 ```key``` 和 ```cert``` 字段指定 ```HTTPS``` 服务器使用的私钥和公钥

```NodeJS``` 支持 ```SNI``` 技术，可以根据 ```HTTPS``` 客户端请求使用的域名动态使用不同的证书，也因此同一个 ```HTTPS``` 服务器可以使用多个域名提供服务

```js
Server.addContent("foo.com", {
    key: fs.readFileSync("./ssl/foo.key"),
    cert: fs.readFileSync("./ssl/foo.cer")
})

Server.addContent("bar.com", {
    key: fs.readFileSync("./ssl/bar.key"),
    cert: fs.readFileSync("./ssl/bar.cer")
})
```

#### 客户端模式

与 ```http``` 模块类似

但是需要注意的是：如果目标服务器的 ```SSL``` 证书是自制的，不是从颁发机构购买的，默认情况下 ```https``` 模块会拒绝连接，提示说证书安全问题

在 ```options``` 里加入 ```rejectUnauthorized: false``` 字段可以禁用对证书有效性的检查，从而允许 ```https``` 模块请求开发环境下使用自制证书的 ```HTTPS``` 服务器

