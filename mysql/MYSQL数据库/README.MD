## 创建数据库（表）

默认的 ```root``` 帐号可以管理所有的数据库

但是我们可以新建一个账户来管理特定的数据库，其他的库则不允许其来操作，以 ```ttt``` 数据库为例，

可以选创建一个 ```ttt``` 数据库然后在给予其权限

```js
create database ttt;

grant all on ttt.* to "test"@"localhost" identified by "test";
```

需要注意注意是，如果之前 ```test``` 帐号已经存在了（比如通过一些 ```web``` 操作 ```mysql``` 管理工具），那最好就不要输入 ```identified by "test"``` 这一句，否则会把原有的密码更改掉

然后使用 ```test``` 帐号进行登录，可以看到，除了系统提供的公用数据库以外，只能看到 ```ttt``` 数据库

```js
+--------------------+
| Database           |
+--------------------+
| information_schema |
| ttt               |
| test               |
+--------------------+
```

然后我们就可以使用 ```ttt``` 数据库来进行操作了，首先使用该数据库：

```js
use ttt;
```

然后可以查看里面的表

```js
show tables;

// 如下显示
// Empty set (0.00 sec)
```

然后来新建表：

```js
create table student(id int(10) primary key auto_increment, name varchar(30), age tinyint(2));

// 显示如下
+---------------+
| Tables_in_ttt |
+---------------+
| student       |
+---------------+
```

可以使用 ```desc``` 命令来查看表的结构：

```js
desc student;

// 显示
+-------+-------------+------+-----+---------+----------------+
| Field | Type        | Null | Key | Default | Extra          |
+-------+-------------+------+-----+---------+----------------+
| id    | int(10)     | NO   | PRI | NULL    | auto_increment |
| name  | varchar(30) | YES  |     | NULL    |                |
| age   | tinyint(2)  | YES  |     | NULL    |                |
+-------+-------------+------+-----+---------+----------------+
```

使用

```js
select * from student;
```

可以发现，是没有内容的，我们可以插入内容（可以插入多条）

```js
insert into student (name, age) values("zhangsan", 22);

// 使用 select * from student; 显示如下
+----+----------+------+
| id | name     | age  |
+----+----------+------+
|  1 | zhangsan |   22 |
|  2 | zhangsan |   22 |
|  3 | zhangsan |   22 |
|  4 | zhangsan |   22 |
|  5 | zhangsan |   22 |
+----+----------+------+
```


## 备份与还原

我们可以使用如下命令来导出我们需要备份的数据库（前提是该帐号有权限操作这个数据库（这里是 ```root``` 帐号））

```js
mysqldump -uroot -p ttt>d:/ttt.sql
```

然后来删除它，在试着还原，使用下面命令来删除表

```js
drop table ttt;
```

退出以后在使用下面命令来还原

```js
mysql -uroot -p ttt < d:/ttt.sql
```

这样就实现了备份与还原


导入数据库有两种方式

* 一种是在登录时执行 ```mysql -uroot -p ttt < d:/ttt.sql```

* 另一种是在使用数据库后（比如：```use t1;``` 后），使用 ```source``` 来导入数据库，例如 ```source d:/ttt.sql```

关于第二种，其实就是执行外部 ```sql``` 文件



## MySQL 数据类型

各种类型的存储范围见 [MySQL 数据类型](http://www.runoob.com/mysql/mysql-data-types.html)

主要记录一些比较常见的

* 整型  分为 十进制（用的较多），十六进制，八进制

* 浮点数  例如 ```233.233```

* 字符串  ```"abc"```， ```""```，由 ```0``` 个或多个字符串组成的数据

* null  空值（不确定的值） 

#### 整型

可以使用 ```unsigned``` 关键字约束来指定存储为非负

也只能插入整型，若是插入浮点型数据，则会截取掉小数部分

几个常用的类型有 ```tinyint```，```smallint```，```mediumint```，```int```，```bigint```

如果不指定区域，则是按默认的取值（比如 ```create table t(id smallint)```  ==>  则插入最大值为 ```32767```（而且控制台会有警告））

#### 浮点型

几个常用的类型有 ```float```（单精度浮点型），```double```（双精度浮点型），```decimal```

关于 ```decimal(M, N)```：

* 用来存储一个准确的值，而不是一个近似的值，一般用于货币，金钱存储

* ```M``` 是指定显示的位数

* ```N``` 是指定小数位数

例如 
```js
// 创建一个 f 表
create table f(price decimal(5, 2));  

// 插入
insert into f(price) values(123.22);

==> 可以正确的插入 123.22

// 插入
insert into f(price) values(4333.22)

==> 没有正确的插入 999.99（而是取了一个近似的值）
```

然后修改一下存储类型

```js
alter table f modify price decimal(10, 2);

==> 这个时候 4333.22 就可以正确的存储进去了
```



## 查询

首先创建一个基础类型的表：

```js
create table stu( id int(10) primary key auto_increment, name char(30) not null, sex tinyint(1) default 0, qq varchar(255)) default character set utf8 engine myisam;

insert into stu(name, sex, qq) values ("李四", 1, 243513263);
// ...
// ...

select * from stu; 

// 表结构如下：

+----+------+------+-----------+
| id | name | sex  | qq        |
+----+------+------+-----------+
|  1 | 李四 |    1 | 243513263 |
|  2 | 李玉 |    0 | 567835673 |
|  3 | 小飞 |    1 | 112345672 |
|  4 | 张美 |    0 | 267323235 |
|  5 | 李华 |    0 | 133242312 |
|  6 | 王五 |    0 | 234234532 |
|  7 | 赵六 |    1 | 575675675 |
+----+------+------+-----------+
```

#### select

```select``` 主要用于查询，下面是一些其他用法：

* ```select version();```  // 显示当前 ```mysql``` 版本信息

* ```select database();```  // 查看当前使用的库

* 也可以设置变量 ```set @x = 2;```  ===>  ```select @x * 200;```

```*``` 会为我们返回所有字段的信息，如果我们只需要个别字段的信息，那么可以使用：

```js
select name, sex from stu;

// ===>

+------+------+
| name | sex  |
+------+------+
| 李四 |    1 |
| 李玉 |    0 |
| 小飞 |    1 |
| 张美 |    0 |
| 李华 |    0 |
| 王五 |    0 |
| 赵六 |    1 |
+------+------+
```

#### where

可以使用 ```where``` 来添加条件约束

```js
select * from stu where name = "李四";

// ===>

+----+------+------+-----------+
| id | name | sex  | qq        |
+----+------+------+-----------+
|  1 | 李四 |    1 | 243513263 |
+----+------+------+-----------+
```

#### like

关键字 ```like``` 用于模糊查找，```%``` 代表一个或多个字段

```js
// 以 李 开头的
select * from stu where name like "李%";

// ===>

+----+------+------+-----------+
| id | name | sex  | qq        |
+----+------+------+-----------+
|  1 | 李四 |    1 | 243513263 |
|  2 | 李玉 |    0 | 567835673 |
|  5 | 李华 |    0 | 133242312 |
+----+------+------+-----------+


// 名字中包含 玉 字的
select * from stu where name like "%玉%";

// ===>

+----+------+------+-----------+
| id | name | sex  | qq        |
+----+------+------+-----------+
|  2 | 李玉 |    0 | 567835673 |
+----+------+------+-----------+
```

#### if

也可以在 ```mysql``` 语句中添加判断：

```js
// 类似三元表达式
select if(sex, "男生", "女生"), name, sex from stu;

// ===>

+-------------------------+------+------+
| if(sex, "男生", "女生") | name | sex  |
+-------------------------+------+------+
| 男生                    | 李四 |    1 |
| 女生                    | 李玉 |    0 |
| 男生                    | 小飞 |    1 |
| 女生                    | 张美 |    0 |
| 女生                    | 李华 |    0 |
| 女生                    | 王五 |    0 |
| 男生                    | 赵六 |    1 |
+-------------------------+------+------+
```

但是这样返回的字段（比如在上例中就是 ```if(sex, "男生", "女生")```）不利于我们操作，这个时候可以使用 ```as``` 关键字（别名）使其变为如下的 ```stusex```：

```js
select if(sex, "男生", "女生") as stusex, name from stu;

// ===>

+--------+------+
| stusex | name |
+--------+------+
| 男生   | 李四 |
| 女生   | 李玉 |
| 男生   | 小飞 |
| 女生   | 张美 |
| 女生   | 李华 |
| 女生   | 王五 |
| 男生   | 赵六 |
+--------+------+
```

#### 查询中的逻辑运算符

比如我们要查询 所有姓李的女生（```and```）：

```js
select name, sex from stu where name like "李%" and sex = 0;

// ===>

+------+------+
| name | sex  |
+------+------+
| 李玉 |    0 |
| 李华 |    0 |
+------+------+
```

比如查询 姓李或者是女生（```or```）：

```js
select name, sex from stu  where name like "李%" or sex = 0;

// ===>

+------+------+
| name | sex  |
+------+------+
| 李四 |    1 |
| 李玉 |    0 |
| 张美 |    0 |
| 李华 |    0 |
| 王五 |    0 |
+------+------+
```

比如想返回一个组合的信息（```concat```）：

```js
select concat("姓名：", name, " 性别：", sex, " QQ：", qq) from stu;

// ===>

+-----------------------------------------------------+
| concat("姓名：", name, " 性别：", sex, " QQ：", qq) |
+-----------------------------------------------------+
| 姓名：李四 性别：1 QQ：243513263                    |
| 姓名：李玉 性别：0 QQ：567835673                    |
| 姓名：小飞 性别：1 QQ：112345672                    |
| 姓名：张美 性别：0 QQ：267323235                    |
| 姓名：李华 性别：0 QQ：133242312                    |
| 姓名：王五 性别：0 QQ：234234532                    |
| 姓名：赵六 性别：1 QQ：575675675                    |
+-----------------------------------------------------+

// 调整下返回字段名
select concat("姓名：", name, " 性别：", sex, " QQ：", qq) as stuinfo from stu;

// ===>

+----------------------------------+
| stuinfo                          |
+----------------------------------+
| 姓名：李四 性别：1 QQ：243513263 |
| 姓名：李玉 性别：0 QQ：567835673 |
| 姓名：小飞 性别：1 QQ：112345672 |
| 姓名：张美 性别：0 QQ：267323235 |
| 姓名：李华 性别：0 QQ：133242312 |
| 姓名：王五 性别：0 QQ：234234532 |
| 姓名：赵六 性别：1 QQ：575675675 |
+----------------------------------+

// 再调整下性别显示
select concat("姓名：", name, " 性别：", if(sex, "男", "女"), " QQ：", qq) as stuinfo from stu;

// ===>

+-----------------------------------+
| stuinfo                           |
+-----------------------------------+
| 姓名：李四 性别：男 QQ：243513263 |
| 姓名：李玉 性别：女 QQ：567835673 |
| 姓名：小飞 性别：男 QQ：112345672 |
| 姓名：张美 性别：女 QQ：267323235 |
| 姓名：李华 性别：女 QQ：133242312 |
| 姓名：王五 性别：女 QQ：234234532 |
| 姓名：赵六 性别：男 QQ：575675675 |
+-----------------------------------+

// 当然也可以添加更多的筛选条件
// where sex = 0; 
// where sex = 0 and name like "%玉%";
// 等等
```



## LIMIT 语句

首先先向表中追加一个字段：

```js
// 修改表 stu 追加（add）一个字段（birday）
// 它是一个日期类型，可以选择使用 int(10)
// 也可以使用 date 来专门处理日期类型
alter table stu add birthday date;

// ===> 

+----+------+------+-----------+----------+
| id | name | sex  | qq        | birthday |
+----+------+------+-----------+----------+
|  1 | 李四 |    1 | 243513263 | NULL     |
|  2 | 李玉 |    0 | 567835673 | NULL     |
|  3 | 小飞 |    1 | 112345672 | NULL     |
|  4 | 张美 |    0 | 267323235 | NULL     |
|  5 | 李华 |    0 | 133242312 | NULL     |
|  6 | 王五 |    0 | 234234532 | NULL     |
|  7 | 赵六 |    1 | 575675675 | NULL     |
+----+------+------+-----------+----------+

// 更新日期
// 下面这样是批量处理
update stu set birthday = "1999/2/22";

// 正常情况我们应当指定条件
update stu set birthday = "1999/2/22" where id = 1;
update stu set birthday = "1995/3/14" where id = 2;
// ...
// ...

// ===>  最后如下所示

+----+------+------+-----------+------------+
| id | name | sex  | qq        | birthday   |
+----+------+------+-----------+------------+
|  1 | 李四 |    1 | 243513263 | 1999-02-22 |
|  2 | 李玉 |    0 | 567835673 | 1995-03-14 |
|  3 | 小飞 |    1 | 112345672 | 2000-04-22 |
|  4 | 张美 |    0 | 267323235 | 2002-06-15 |
|  5 | 李华 |    0 | 133242312 | 1988-02-01 |
|  6 | 王五 |    0 | 234234532 | 1999-08-23 |
|  7 | 赵六 |    1 | 575675675 | 1996-11-14 |
+----+------+------+-----------+------------+
```

#### limit

在看 ```limit``` 之前，我们先来看看 ```order by```：

* 使用 ```order by``` 可以指定排序顺序

* 使用 ```desc``` 使其 **降序** 排列（```54321```）

* 使用 ```asc``` 使其 **升序** 排列（```12345```）

```js
select * from stu order by id;

// ===>

+----+------+------+-----------+------------+
| id | name | sex  | qq        | birthday   |
+----+------+------+-----------+------------+
|  1 | 李四 |    1 | 243513263 | 1999-02-22 |
|  2 | 李玉 |    0 | 567835673 | 1995-03-14 |
|  3 | 小飞 |    1 | 112345672 | 2000-04-22 |
|  4 | 张美 |    0 | 267323235 | 2002-06-15 |
|  5 | 李华 |    0 | 133242312 | 1988-02-01 |
|  6 | 王五 |    0 | 234234532 | 1999-08-23 |
|  7 | 赵六 |    1 | 575675675 | 1996-11-14 |
+----+------+------+-----------+------------+

select * from stu order by id desc;

// ===>

+----+------+------+-----------+------------+
| id | name | sex  | qq        | birthday   |
+----+------+------+-----------+------------+
|  7 | 赵六 |    1 | 575675675 | 1996-11-14 |
|  6 | 王五 |    0 | 234234532 | 1999-08-23 |
|  5 | 李华 |    0 | 133242312 | 1988-02-01 |
|  4 | 张美 |    0 | 267323235 | 2002-06-15 |
|  3 | 小飞 |    1 | 112345672 | 2000-04-22 |
|  2 | 李玉 |    0 | 567835673 | 1995-03-14 |
|  1 | 李四 |    1 | 243513263 | 1999-02-22 |
+----+------+------+-----------+------------+ 
```

```limit``` 一般用来取部分数据，常用于分页等

```limit``` 往往是配合 ```order by``` 来使用，这样能保证得到的结果是我们预期想要的

```js
// 取出 id 最大的两条数据
select * from stu order by id desc limit 2;

// ===>
+----+------+------+-----------+------------+
| id | name | sex  | qq        | birthday   |
+----+------+------+-----------+------------+
|  7 | 赵六 |    1 | 575675675 | 1996-11-14 |
|  6 | 王五 |    0 | 234234532 | 1999-08-23 |
+----+------+------+-----------+------------+
```

查找年龄最大的用户：

```js
select name, birthday from stu order by birthday asc limit 1;

// ===>

+------+------------+
| name | birthday   |
+------+------------+
| 李华 | 1988-02-01 |
+------+------------+
```

查找年龄最小的用户：

```js
// 同上，只需要将排序方式由 asc -> desc 即可
select name, birthday from stu order by birthday desc limit 1;

// ===>

+------+------------+
| name | birthday   |
+------+------------+
| 张美 | 2002-06-15 |
+------+------------+
```

在使用 ```limit``` 的时候，如果只指定一个参数，那么只取出一条记录，如果指定了两个参数，那么第一个参数就代表**起始点**（第几条开始取，默认索引从 0 开始，与数组类似），第二个参数代表**取几条**（也会包含起始的那条）

#### 临时表

思考如下问题：

现在如果我们将年龄排名第二与第三的用户调整为年龄一样大小，即如下所示：

```js
update stu set birthday = "1995/3/14" where id = 3;

select * from stu order by birthday;

// ===>

+----+------+------+-----------+------------+
| id | name | sex  | qq        | birthday   |
+----+------+------+-----------+------------+
|  5 | 李华 |    0 | 133242312 | 1988-02-01 |
|  2 | 李玉 |    0 | 567835673 | 1995-03-14 |
|  3 | 小飞 |    1 | 112345672 | 1995-03-14 |
|  7 | 赵六 |    1 | 575675675 | 1996-11-14 |
|  1 | 李四 |    1 | 243513263 | 1999-02-22 |
|  6 | 王五 |    0 | 234234532 | 1999-08-23 |
|  4 | 张美 |    0 | 267323235 | 2002-06-15 |
+----+------+------+-----------+------------+
```

这个时候如果要取出**年龄最大的前两名**的话就会出现问题：

```js
select * from stu order by birthday limit 2;

// ===>

+----+------+------+-----------+------------+
| id | name | sex  | qq        | birthday   |
+----+------+------+-----------+------------+
|  5 | 李华 |    0 | 133242312 | 1988-02-01 |
|  3 | 小飞 |    1 | 112345672 | 1995-03-14 |
+----+------+------+-----------+------------+
```

可以看到，只有两条数据，这显然不是我们想要的，这个时候就可以通过一个子查询产生一张临时表，通过这张临时表来返回我们需要的数据

```js
select * from stu where birthday <= (select birthday from stu order by birthday limit 1, 1);

// ===>

+----+------+------+-----------+------------+
| id | name | sex  | qq        | birthday   |
+----+------+------+-----------+------------+
|  2 | 李玉 |    0 | 567835673 | 1995-03-14 |
|  3 | 小飞 |    1 | 112345672 | 1995-03-14 |
|  5 | 李华 |    0 | 133242312 | 1988-02-01 |
+----+------+------+-----------+------------+
```

#### 过滤重复内容

看下面这个案例，得到所有用户的生日年份

```js
// 因为是 date 类型，所有可以直接使用 year(birthday) 来获取年份
select year(birthday) from stu;

// ===>

+----------------+
| year(birthday) |
+----------------+
|           1999 |
|           1995 |
|           1995 |
|           2002 |
|           1988 |
|           1999 |
|           1996 |
+----------------+
```

我们可以看到，有重复的 ```1995``` 和 ```1999```，这个时候我们就需要过滤掉这些重复的内容，这个时候就可以使用 ```distinct``` 这个关键字：

```js
select distinct year(birthday) form stu;

+----------------+
| year(birthday) |
+----------------+
|           1999 |
|           1995 |
|           2002 |
|           1988 |
|           1996 |
+----------------+
```