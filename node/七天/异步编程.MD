## 异步编程

#### 回调

在代码中，异步编程的直接体现就是回调，异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了

```js
function heavyCompute (n, callback) {
    
    var count = 0,
        i, j;
    
    for (i = n; i > 0; i--) {
        for (j = n; j > 0; j--) {
            count += 1;
        }
    }

    callback(count)
}

heavyCompute(10000, function (count) {
    console.log(count)
})

console.log("hello")

// 100000000
// hello
```

可以看到，以上代码中的回调函数仍然先于后续代码执行，```JS``` 本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念

但是某个函数做的事情就是创建一个别的线程或进程，并于 ```JS``` 主线程并行做一些事情，并在事件处理完成后通知 ```JS``` 主线程，那情况油不一样了

```js
setTimeout(function () {
    console.log(`world`)
})

console.log(`hello`)

// hello
// world
```

这次可以看到，回调函数后于后续代码执行了

所以说，```JS``` 本身是单线程的，无法异步执行，因此我们可以认为 ```setTimeout``` 这类 ```JS``` 规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让 ```JS``` 主线程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数

需要注意的是，即使平行线程完成工作了，通知 ```JS``` 主线程执行回调函数了，仍要等到 ```JS``` 主线程空闲时才能开始执行

```js
function heavyCompute (n) {
    var count = 0,
        i, j;

    for (i = n; i > 0; i--) {
        for (j = n; j > 0; j--) {
            count += 1;
        }
    }
}

var t = new Date();

setTimeout(function () {
    console.log(new Date() - t);
}, 1000)

heavyCompute(5000)  // 1001
```
