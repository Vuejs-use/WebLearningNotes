主要参考 [深入理解javascript原型和闭包](http://www.cnblogs.com/wangfupeng1988/p/3977987.html)

----

## 对象 - 若干属性的集合

```js
// 简单的值类型，不是对象
console.log(typeof x);                 // undefined
console.log(typeof 10);                // number
console.log(typeof 'abc');             // string
console.log(typeof true);              // boolean

// 函数其实也是对象，也是可以做为参数传递的
console.log(typeof function () { });   //function

// 引用类型
console.log(typeof [1, 'a', true]);    //object
console.log(typeof { a: 10, b: 20 });  //object
console.log(typeof null);              //object
console.log(typeof new Number(10));    //object
```

判断一个变量是不是对象，值类型的类型判断用 typeof，引用类型的类型判断用 instanceof


## 函数和对象的关系

对象是可以通过函数来创建

```js
//var obj = { a: 10, b: 20 };
//var arr = [5, 'x', true];

var obj = new Object();
obj.a = 10;
obj.b = 20;

var arr = new Array();
arr[0] = 5;
arr[1] = 'x';
arr[2] = true;
```

## prototype

每个函数都有一个属性叫做 prorotype，这个 prototype 的属性值是一个对象（属性的集合），默认的还有一个叫做 constructor 的属性，指向这个函数本身

![prototype01](http://images.cnitblog.com/blog/138012/201409/172121182841896.png)

例如 Object 的 prototype 上就挂载了一系列方法

![prototype02](http://images.cnitblog.com/blog/138012/201409/172130097842386.png)

我们也可以在自己自定义的方法的 prototype 中新增自己的属性

```js
function Foo () {...}

Foo.prototype.name = ..

Foo.prototype.getName = function () {..}

var bar = new Foo();
console.log(bar.name);
console.log(bar.getName());
```

Foo 是一个函数，bar 对象是通过 Foo 函数 new 出来的，这样一来，bar 对象就可以调用 Foo.prototype 上的属性和方法

因为每个对象都有一个隐藏的属性 __proto__（一般称为 隐式原型），这个属性引用了创建这个对象的函数的 prototype，即

```js
bar.__proto__ === Foo.prototype  // true
```

## instanceof

对于值类型可以使用 typeof 判断，但是对于引用类型的时候，返回值只有 object/function，这个时候就可以使用 instanceof

![instanceof](http://images.cnitblog.com/blog/138012/201409/181635468939277.png)

比如判断 f1 instanceof Object，按照上图来说就是：

* 沿着 f1 的 __proto__ 这条线来找，同时沿着 Object 的 prototype 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 true，如果找到终点还未重合，则返回 false

这也解释了为何一下结果均返回 true

```js
Object instanceof Function;    // true

Function instanceof Object;    // true

Function instanceof Function;  // true
```

完整原型图如下所示：

![原型链](http://images.cnitblog.com/blog/138012/201409/181637013624694.png)

* instanceof 表示的就是一种继承关系，或者原型链的结构

一个小小的练习题：

```js
var a = {
    x: 1,
    y: { z: 2 }
};

var b = {};
b.__proto__ = a;

// a 和 b 都是对象（通过new Object() 生成，这里是简写）
// 所以 a.__proto__ === b.__proto__ 是相等的（都是指向 Object.prototype）
// 所以在查找 b.x 的时候先去 b 查看，发现是空对象（{}），原则上应该去 Object.prototype 上查找 
// 但是现在把 b.__proto__ 从新指回了 a，所以应该就去 a 上查找
// 所以 b.x 为 1，b.y 为 { z: 2 }
console.log(a.x);
console.log(b.x);

// 然后把 b.x 重新赋值为 22
// 因为是基本类型，所以 a.x 是不变的
b.x = 22;
console.log(a.x);
console.log(b.x);

// 这个同上面那个类似
// 但是由于是引用类型，所以 a.y 和 b.y 指向的都是同一个地址
// 其中一个变化的话自然会引起另外一个变化
b.y.z = 33;
console.log(a.y.z);
console.log(b.y.z);
```