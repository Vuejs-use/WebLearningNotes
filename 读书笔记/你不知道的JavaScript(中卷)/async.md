## 异步

- JavaScript 程序总是至少分为两个块：第一块现在运行，下一块将来运行，以响应某个事件，尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累积的修改之上进行的

- 一旦有事件需要运行，事件轮询就会运行，直到队列清空，事件循环的每一轮称为一个 tick，用户交互、IO和定时器会向事件队列中加入事件

- 任意时刻，一次只能从队列中处理一个事件，执行事件的时候，可能直接或间接地引发一个或多个后续事件

- 并发是指两个或多个事件链随事件发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管任意时刻只处理一个事件）

- 通常需要对这些并发执行的 "进程"（有别于操作系统中的进程概念）进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现，这些 "进程" 也可以通过把自身分割成更小的块，以便其他 "进程" 插入进来

## Promise

先来看一个简单的示例：

```js
function add (x, y) {
    // Promise.all() 接收一个 promise 数组并返回一个新的 promise
    // 这个 promise 等待数组中所有 promise 完成
    // 然后将接收到的 x 和 y 相加
    // then 中的 values 来自于之前的消息数组
    return Promise.all([x, y]).then(function (values) {
        return values[0] + values[1]
    })
}

// add 返回值为 promise
// 链式调用来获取最后的输出值
add(fromX(), fromY()).then(function (sum) {
    console.log(sum)
}, function (err) {
    console.log(err)
})
```

- 从外部来看，由于 Promise 封装了依赖于时间的状态 -- 等待底层值的完成或拒绝，所以 Promise 本身与时间无法的，因此，Promise 可以按照可预测的方式组成（组合），而不用关心时序或底层的结果

- 另外，一旦 Promise 决议，它就永远保持在这个状态，此时它就称为了不变值（immutable value），可以根据需求多次查看

- 再次强调，Promise 决议后就是**外部不可变**的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意的修改（特别是对于多方查看同一个 Promise 决议的情况）