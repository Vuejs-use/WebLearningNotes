## 实例化和原型

所有 functions 都拥有一个属性：prototype，初始化中的 prototype 都指向一个空的 object

这个属性只是在这个函数被当作构造器来调用的时候，才会有作用（其他情况下没啥用）

当使用关键字 new 来调用一个函数，这个函数就成为了构造器，它会产生一个新的对象实例作为他的函数上下文（function context）

#### 对象实例化

先来看看使用和不使用 new 关键字分别会造成什么结果

```js
function Ninja() { }
Ninja.prototype.swingSord = function () {
    return true;
}

// 不使用 new
var ninja1 = Ninja();

assert(ninja1 === undefined, "No instance of Ninja created.");

// 使用 new 关键字
var ninja2 = new Ninja();
assert(ninja2 && ninja2.swingSword(), "Instance exists and method iscallable."); 
```

从上面的例子可以看出，函数的 ```prototype``` 作为 new 出来的对象的蓝图，但是前题是这个函数是被当作构造函数来调用才行。

当使用构造函数通过 new 关键字来构建一个对象实例的时候，这就意味着我们可以在构造函数中通过 prototype 来初始化一些值。

```js
function Ninja() {
    thisswung = false;
    this.swingSword = function () {
        return !this.swung;
    }
}

Ninja.prototype.swingSword = function () {
    return this.swung;
}

var ninja = new Ninja();

assert(ninja.swingSword(), "Called the instance method, not the prototypemethod."); 
```

prototype 不是简单的拷贝

简单的时序如下：

1. 当你查看一个对象的属性，首先，这个对象检查真身的属性中是否存在，如果存在则使用这个值，如果不存在…

2. 他会检查与他有关的那个 ```prototype```，如果 ```prototype``` 存在这个属性，则使用此值，如果不存在…

3. 这个值就是 ```undefined```

待续...












































