## 数组的解构

```js
var [a, b, c] = [1, 2, 3]
```

这种写法属于 "模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo  // 1
bar  // 2
baz  // 3

let [ , , third] = ["foo", "bar", "baz"];
third  // "baz"

let [x, , y] = [1, 2, 3];
x  // 1
y  // 3

let [head, ...tail] = [1, 2, 3, 4];
head  // 1
tail  // [2, 3, 4]

let [x, y, ...z] = ["a"];
x  // "a"
y  // undefined
z  // []
```

如果解构不成功，变量的值就等于 ```undefined```

另外一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，这种情况下，仍然可以解构成功

```js
let [x, y] = [1, 2, 3];
x  // 1
y  // 2

let [a, [b], c] = [1, [2, 3], 4];
a  // 1
b  // 2
d  // 4
```

需要注意的是，如果等号右边不是数组（不是可遍历的解构，不具有 ```Iterator``` 接口），那么将会报错（number，string，false，NaN，undefined，null，{ } 等）

事实上，只要某种数据具有 ```Iterator``` 接口，都可以采用数组形式的解构赋值

```js
function* fibs() {
    var a = 0;
    var b = 1;
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

var [first, second, third, fourth, fifth, sixth] = fibs();
sixth  // 5
```

上面代码中，```fibs``` 是一个 ```Generator``` 函数，原生具有 ```Iterator``` 接口。解构赋值会依次从这个接口获取值。


#### 默认值

解构赋值允许指定默认值

```js
var [foo = true] = [];
foo  // true

[x, y = "b"] = ["a"];  // x = "a", y = "b"
[x, y = "b"] = ["a", undefined];  // x = "a", y = "b"  
```

需要注意的是，ES6 内部使用的是严格相等运算符 ```===```来判断一个位置是否有值（类似 null 等是不会生效的）

默认值可以引用解构赋值的其他变量，但该变量必须已经声明

```js
let [x = 1, y = x] = [];  // x = 1, y = 1
let [x = 1, y = x] = [2];  // x = 2, y = 2
let [x = 1, y = x] = [1, 2];  // x = 1, y = 2
let [x = y, y = 1] = [];  // 报错
```



## 对象的解构

解构不仅可以用于数组，还可以用于对象

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" }
foo  // "aaa"
bar  // "bbb"
```

数组的元素是按次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值

实际上，对象的解构赋值是下面形式的简写：

```js
var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" }
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后在赋予给对应的变量，真正被赋值的是后者，而不是前者

对于 ```let``` 和 ```const``` 来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错

```js
let foo;
let {foo} = { foo: 1 }; // Duplicate declaration "foo"

let baz;
let {bar: baz} = { bar: 1 }; // Duplicate declaration "baz"
```

因为 ```var``` 命令允许重复新声明，如果没有第二个 ```let``` 命令，上面的代码就不会出错

```js
let foo;
({ foo } = { foo: 1 }); // success

let baz;
({ bar: baz } = { bar: 1 }); // success
```

需要注意的是：圆括号是必须的，否则会报错，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句

对象的解构也可以指定默认值

```js
var {x = 3} = {};
x  // 3

var {x, y = 5} = { x: 1 };
x  // 1
y  // 5

var {x: y = 3} = {};
y  // 3

var {x: y = 3} = { x: 5 };
y  // 5

var { message: msg = "Something went wrong" } = {};
msg  // "Something went wrong"
```

默认值的生效条件和数组是一致的，对象的属性严格等于(===) ```undefined```

对象的解构赋值，可以很方便的将现有对象的方法，赋值到某个变量

```js
let { log, sin, cos } = Math;  // 将 Math 对象的对数，正弦，余弦三个方法赋值到对应的变量上
```

由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构

```js
var arr = [1, 2, 3];

var { 0: first, [arr.length - 1]: last } = arr;

fisrt  // 1
last  // 3
```

数组 ```arr``` 的 ```0``` 键对应的值是 ```1```，```[arr.length - 1]``` 就是 ```2``` 键，对应的值是 ```3```