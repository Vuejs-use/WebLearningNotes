## 数组的解构

```js
var [a, b, c] = [1, 2, 3]
```

这种写法属于 "模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo  // 1
bar  // 2
baz  // 3

let [ , , third] = ["foo", "bar", "baz"];
third  // "baz"

let [x, , y] = [1, 2, 3];
x  // 1
y  // 3

let [head, ...tail] = [1, 2, 3, 4];
head  // 1
tail  // [2, 3, 4]

let [x, y, ...z] = ["a"];
x  // "a"
y  // undefined
z  // []
```

如果解构不成功，变量的值就等于 ```undefined```

另外一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，这种情况下，仍然可以解构成功

```js
let [x, y] = [1, 2, 3];
x  // 1
y  // 2

let [a, [b], c] = [1, [2, 3], 4];
a  // 1
b  // 2
d  // 4
```

需要注意的是，如果等号右边不是数组（不是可遍历的解构，不具有 ```Iterator``` 接口），那么将会报错（number，string，false，NaN，undefined，null，{ } 等）

事实上，只要某种数据具有 ```Iterator``` 接口，都可以采用数组形式的解构赋值

```js
function* fibs() {
    var a = 0;
    var b = 1;
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

var [first, second, third, fourth, fifth, sixth] = fibs();
sixth  // 5
```

上面代码中，```fibs``` 是一个 ```Generator``` 函数，原生具有 ```Iterator``` 接口。解构赋值会依次从这个接口获取值。




