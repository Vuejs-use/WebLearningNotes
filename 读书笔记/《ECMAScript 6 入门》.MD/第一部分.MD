## let 命令

#### 暂时性死区

只要块级作用域内存在 let 命令，它所声明的变量就 "绑定"（binding）这个区域，不再受外部的影响。

```js
var tmp = 123;

if (true) {
    tmp = "abc";  // tmp is not defined
    let tmp;
}
```

这也就意味着 ```typeof``` 不再是一个百分比安全的操作

```js
typeof x;  // x is not defined

let x;
```

作为比较，如果一个变量根本没有被声明，使用 ```typeof``` 反而不会报错。

```js
typeof y;  // "undefined"
```


#### 比较隐蔽的死区

```js
function bar(x = y, y = 2) {
    return [x, y];
}

bar(); // y is not defined
```

因为参数 x 默认值等于另一个参数 y，而此时 y 还没有声明，属于 "死区"，如果 y 的默认值是 x，就不会报错，因为此时 x 已经声明了

```js
function bar(x = 2, y = x) {
    return [x, y];
}

bar(); // [2, 2]
```

总之：先声明，在使用



#### 不允许重复声明

```js
function add () {
    let a = 10;  // 报错
    var a = 1;
}

function foo(arg) {
    let arg;  // 报错
}

function func(arg) {
    {
        let arg;  // 不报错
    }
}
```



## 块级作用域

第一种场景，内层变量可能会覆盖外层变量。

```js
var tmp = new Date();

function f() {
    // var tmp
    console.log(tmp);
    if (false) {
        // tmp = "hello world";
        var tmp = "hello world";
    }
}

f();  // undefined
```

第二种场景，用来计数的循环变量泄露为全局变量。

```js
var s = 'hello';

for (var i = 0; i < s.length; i++) {
    console.log(s[i]);
}

console.log(i);  // 5
```

let 实际上为 JavaScript 新增了块级作用域。

```js
function f1() {
    let n = 5;
    if (true) {
        let n = 10;
    }
    console.log(n); // 5（外层代码块不受内层代码块的影响）
}
```

块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

```js
// IIFE 写法
(function () {
    var tmp = ...;
  ...
} ());

// 块级作用域写法
{
    let tmp = ...;
  ...
}
```