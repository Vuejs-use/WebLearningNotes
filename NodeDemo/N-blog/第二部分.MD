## 3 初始化一个 Express 

### supervisor

使用 supervisor 来解决修改代码需要 结束/启动 服务，全局安装 supervisor：

```js
npm install -g supervisor
```

运行 supervisor --harmony index 启动程序，如下所示：

![image](https://github.com/nswbmw/N-blog/blob/master/book/img/3.1.2.png)

supervisor 会监听当前目录下 node 和 js 后缀的文件，当这些文件发生改动时，supervisor 会自动重启程序。


### --harmony

ES6，也就是被大众称为 JavaScript 的 ECMAScript 语言规范的下一版，其工作名称为 ```Harmony```。 Harmony 给 JavaScript 带来了很多振奋人心的新特性，其中很多已经出现在较新版本的 node 中了。

Harmony 实现了很多新特性，比如```块作用域```、```生成器```、```代理```、```弱映射```等等。

要在你的 node 程序中启用 harmony 的特性，需要在启动脚本中设置 --harmony 选项，例如：

```js

supervisor --harmony index

```


## 3.2 路由

默认的例子我们只是挂载了根路径的路由控制器，然后我们现在新增一个路径：

```js

app.get("/users/:name", function (req, res) {
    res.send("hello " + req.params.name)
})

```

路径中 :name 起了占位符的作用，这个占位符的名字是 name，可以通过 req.params.name 取到实际的值。

> express 使用了 [path-to-regexp](https://www.npmjs.com/package/path-to-regexp) 模块实现的路由匹配。

req 中包含了**请求来的相关信息**，res 则是用来**返回该请求的响应**，更多见 [express](http://expressjs.com/en/4x/api.html) 官方文档。

几个常用的 req 的属性：

* ```req.query```: 解析后的 url 中的 ```querystring```，如 ```?name=haha```，```req.query``` 的值为 ```{name: 'haha'}```

* ```req.params```: 解析 url 中的占位符，如 ```/:name```，访问 ```/haha```，```req.params``` 的值为 ```{name: 'haha'}```

* ```req.body```: 解析后请求体，需使用相关的模块，如 [body-parser](https://www.npmjs.com/package/body-parser)，请求体为 ```{"name": "haha"}```，则 ```req.body``` 为 ```{name: 'haha'}```




### express.Router

利用 路由 来改造之前的例子

创建 routes 文件夹，在 routes 目录下创建 index.js 和 users.js。最后代码如下：

```js

// index.js
var express = require('express');
var app = express();
var indexRouter = require('./routes/index');
var userRouter = require('./routes/users');

app.use('/', indexRouter);
app.use('/users', userRouter);

app.listen(3000);



// routes/index.js
var express = require('express');
var router = express.Router();

router.get('/', function(req, res) {
  res.send('hello, express');
});

module.exports = router;



// routes/users.js
var express = require('express');
var router = express.Router();

router.get('/:name', function(req, res) {
  res.send('hello, ' + req.params.name);
});

module.exports = router;


```

每个路由文件通过生成一个 ```express.Router``` 实例 ```router``` 并导出，通过 ```app.use``` 挂载到不同的路径。

更多 express.Router 的用法见 [express 官方文档](http://expressjs.com/en/4x/api.html#router)




### 模板引擎

模板引擎（Template Engine）是一个将页面模板和数据结合起来生成 html 的工具。

### ejs

ejs 有 3 种常用标签：

1. ```<% code %>```：运行 JavaScript 代码，不输出

2. ```<%= code %>```：显示转义后的 HTML内容

3. ```<%- code %>```：显示原始 HTML 内容

> 注意：<%= code %> 和 <%- code %> 都可以是 JavaScript 表达式生成的字符串，当变量 code 为普通字符串时，两者没有区别。当 code 比如为 ```<h1>hello</h1>``` 这种字符串时，```<%= code %>``` 会原样输出 ```<h1>hello</h1>```，而 ```<%- code %>``` 则会显示 H1 大的 hello 字符串。

下面的例子解释了 ```<% code %>``` 的用法：

Data

```
supplies: ['mop', 'broom', 'duster']
```

Template
```
<ul>
<% for(var i=0; i<supplies.length; i++) {%>
   <li><%= supplies[i] %></li>
<% } %>
</ul>
```

Result
```
<ul>
  <li>mop</li>
  <li>broom</li>
  <li>duster</li>
</ul>
```

更多 ejs 的标签请看 [官方文档](https://www.npmjs.com/package/ejs#tags)


### includes

我们将原来的 ```users.ejs``` 拆成出了 ```header.ejs``` 和 ```footer.ejs```，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。

拆分模板组件通常有两个好处：

1. 模板可复用，减少重复代码

2. 主模板结构清晰

> 注意：要用 ```<%- include('header') %>``` 而不是 ```<%= include('header') %>```



## express


利用 Express，可以方便我们实现web服务实际上涉及到了很多很多的内容：

* url路由，url参数读取，以及表单读取

* 对于不同http方法（GET、POST、PUT）的分发

* 自动填写HTTP头，例如Content-Type

* cookie、session的管理

* 用户管理，包括用户名判重、密码加密和保持登陆

* 模板渲染，将动态的脚本渲染成浏览器可识别的HTML

* 静态文件服务

* 用户上传文件

* 国际化，创建语言无关的站点

* MVC支持（良好的代码结构可极大的提高代码的可读性和可维护性）

...

express 的精髓在于中间件的设计理念。

express 通过其中间件机制实现了这些功能的管理。每一个中间件对应一个功能，而中间件可以是第三方库，也可以是我们的业务逻辑。

### 中间件与 next

express 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件，如果没有调用 next()，则请求不会往下传递

如内置的 ```res.render``` 其实就是渲染完 html 直接返回给客户端，没有调用 next()，从而没有传递给下一个中间件。

```js

var express = require("express");
var app = express();

app.use(function (req, res, next) {
    console.log(1)
    next()
})

app.use(function (req, res, next) {
    console.log(2)
    res.status(200).end();
})

app.listen(3000)

```

通过 app.use 加载中间件，在中间件中通过 next 将请求传递到下一个中间件，next 可接受一个参数接收错误信息，如果使用了 next(error)，则会返回错误而不会传递到下一个中间件

更多见：[官方文档](http://expressjs.com/en/4x/api.html#app.use)

几个常用的搜索 npm 模块的网站：

1. http://npmjs.com(npm 官网)

2. http://node-modules.com

3. https://npms.io

4. https://nodejsmodules.org

> express@4 之前的版本基于 connect 这个模块实现的中间件的架构，express@4 及以上的版本则移除了对 connect 的依赖自己实现了，理论上基于 connect 的中间件（通常以 connect- 开头，如 connect-mongo）仍可结合 express 使用。

> 需要注意的是：中间件的加载顺序很重要！比如：通常把日志中间件放到比较靠前的位置，后面将会介绍的 connect-flash 中间件是基于 session 的，所以需要在 express-session 后加载。

假如我们想手动控制返回的错误内容，则需要加载一个自定义错误处理的中间件

[express 的错误处理官方文档](http://expressjs.com/en/guide/error-handling.html)
